/*******************************************************
*                 Постановка задачи:                   *
*	В условиях задачи 2.10 вычислите вероятность по-   *
* ражения цели W с той лишь разницей, что истребитель  *
* ведет заградительную стрельбу с прямолинейного поле- *
* та.                                                  *
*         Выполнили: 07-408. Мацепура. Бутко           *
*                       2013г.                         *
********************************************************/
#include <iostream>
#include <iomanip>
#include <conio.h>
#include <cmath>

#define PI 3.14159265358   //Число ПИ

//Условия атаки:
double V_target  = 200.0;  //Скорость цели
double V_fighter = 250.0;  //Скорость истребителя
double H         = 4000.0; //Высота полета цели
double q_degree  = 170.0;  //Курсовой угол цели
double D         = 600.0;  //Дальность стрельбы
double q;                  //Курсовой угол в радианах 
double psi;                //Угол упреждения
double V_average;          //Средняя скорость полета снаряда
/* Атака - в плоскости полета цели; цель летит 
в горизонтальной плоскости прямолинейно и равномерно. */

//Схема вооружения истребителя:
int    K   = 1;     //Число пушек
int    N   = 60;    //Темп стрельбы
int    C   = 2;     //Баллистический коэффициент по Сиаччи
double V_0 = 750.0; //Начальная скорость снарядов
//Орудие установлено вдоль продольной оси истребителя

//Режим стрельбы: сопроводительная стрельба.
double t_shoot = 1; //Время стрельбы

//Характеристики углового рассеивания снарядов:
double m_z       = 0;
double m_y       = 0;
double sigma_z_t = 0.006;
double sigma_y_t = 0.006;
double mu_z      = 0.75;
double mu_y      = 0.75;

//Геометрия и уязвимость цели:
double S_b   = 30; //Площадь проекции цели на пл-ть симметрии
//Площадь проекции на плоскость, перпендикулярную продольной оси:
double S_m   = 5;  
double d_f   = 2; //Наибольший диаметр фюзеляжа
int    omega = 4; //Среднее число попаданий, необходимое для поражения цели
//Условный закон поражения цели - показательный

//------------------------------------------------------------------------
//Функция ошибок
double erf(double x)
{
    x /= sqrt(2.);
	//Константы:
    double a1 =  0.254829592;
    double a2 = -0.284496736;
    double a3 =  1.421413741;
    double a4 = -1.453152027;
    double a5 =  1.061405429;
    double p  =  0.3275911;

    int sign = 1;
    if (x < 0)
        sign = -1;
    x = fabs(x);

    double t = 1.0 / (1.0 + p * x);
    double y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x * x);

    return sign * y;
}

//------------------------------------------------------------------------
//Функция нахождения минимума из 2 чисел
double min(double a, double b) 
{
	return a < b ? a: b;
}
//------------------------------------------------------------------------
//Функция перевода градусов в радианы
double degreeToRad(double degree)
{
	return degree * PI / 180.0;
}

//------------------------------------------------------------------------
// Функция, возвращающая интерполированное значение табличной функции fm
double fm(double V_01, double CH_Dy)
{
	//Табличная функция:
	double x[] = {0,    500, 1000, 1500, 2000}; 
	double y[] = {1000, 930, 862,  798,  728}; 
	int size_arr = sizeof(x) / sizeof(x[0]); //Определяем размер массива

	//Методом линейной интерполяции определяем значение функции fm(V_01, CH * Dy):
	int i = 0;
    for (i = 0; i < size_arr; i++)
        if (CH_Dy > x[i]) break;
    if (i == size_arr - 1) return y[i];

    return y[i] + (y[i+1] - y[i]) * ((CH_Dy - x[i]) / (x[i+1] - x[i]));
}

//------------------------------------------------------------------------
//Функция нахождения упрежденной дальности
double D_y()
{
	double Dy;
	double V_01 = V_0 + V_fighter; //Абсолютная скорость снаряда
	double HH   = 0.668; //Значение табличной ф-ции H(H) на высоте 4000м 
	double CH   = C * HH; //Приведенный баллистический коэффициент
		   q    = degreeToRad(q_degree);
	/* Найдем упрежденную дальность методом последовательных приближений
	   с помощью системы уравнений, приведенных ниже: */
	/* Для первой итерации примем среднюю скорость полета снарядов на 
	   дальности Dy равной V_01 */
	V_average = V_01; 

	for (int i = 0; i < 3; i++)
	{
		//Расчет угла упреждения:
		psi = asin( sin( (V_target * sin(q)) / V_average ) );
		//Расчет упрежденной дальности:
		Dy  = D / ( cos(psi) + (V_target / V_average) * cos(q) );
		//Расчет средней скорости полета снарядов:
		V_average = fm(V_01, CH * Dy);
	}
	return Dy;
}

void main()
{
	/* Объявляем и инициализируем переменную Dy результатом 
	   функции нахождения упрежденной дальности: */
	double Dy = D_y();  
	std::cout << "Dy" << std::setw(11) << "= " << Dy << std::endl;

	/* Характеристики рассеивания на картинной плоскости P^(2),
	   перпендикулярной Dy: */
	double sigma_z = sigma_z_t * Dy;
	double sigma_y = sigma_y_t * Dy;
	std::cout << "Sigma_z" << std::setw(6) << "= " << sigma_z << std::endl;
	std::cout << "Sigma_y" << std::setw(6) << "= " << sigma_y << std::endl;

	//Площадь проекции цели на той же картинной плоскости:
	double S_target = S_b * sin(q) + S_m * abs( cos(q) );
	std::cout << "S_target" << std::setw(5) << "= " << S_target << std::endl;

	//Размеры эквивалентного по площади прямоугольника:
	double l_y = d_f / 2;
	double l_z = S_target / (4 * l_y);
	std::cout << "l_y" << std::setw(10) << "= " << l_y << std::endl;
	std::cout << "l_z" << std::setw(10) << "= " << l_z << std::endl;

	/* Скорость перемещения центра цели относительно центра рассеивания 
	при прямолинейном полете истребителя: */
	double V_target_r = ((V_target * sin(q)) / cos(psi)) * (1 - V_fighter/V_average);
	std::cout << "V_target_r" << std::setw(3) << "= " << V_target_r << std::endl;

	//Коэффициенты, характеризующие относительные размеры проекции цели:
	double xi_z_2 =   1. + (1./3.) * pow(l_z / sigma_z, 2);
	std::cout << "xi_z_2" << std::setw(5) << "= " << xi_z_2 << std::endl;
	double xi_y_2 =   1. + (1./3.) * pow(l_y / sigma_y, 2);
	std::cout << "xi_y_2" << std::setw(5) << "= " << xi_y_2 << std::endl;

	//Эффективное время стрельбы:
	double t_eff = (2 * l_z + 6 * sigma_z) / V_target_r;
	std::cout << "t_eff" << std::setw(8) << "= " << t_eff << std::endl;

	//Число выстрелов, соответствующее t_eff:
	double n_eff = min(t_shoot, t_eff) * K * N;
	std::cout << "n_eff" << std::setw(8) << "= " << n_eff << std::endl;

	//Вероятность попадания среднего выстрела очереди:
	double p = erf(l_z / sigma_z) * erf(l_y / sigma_y);
	std::cout << "p" << std::setw(12) << "= " << p << std::endl;

	/* Половина полосы рассредоточения центра цели относительно центра
	   рассеивания(т.е. искусственного рассеивания): */
	double z_n_ = 0.5 * min(t_shoot, t_eff) * V_target_r;
	std::cout << "z_n_" << std::setw(9) << "= " << z_n_ << std::endl;

	//Для удобства сделаем временную переменную, равную:
	double temp = z_n_ / (sigma_z * sqrt(xi_z_2));

	double M = (sqrt(2 * PI) / 2) * (n_eff / omega) * p * ( erf(temp) / temp );
	std::cout << "M" << std::setw(12) << "= " << M << std::endl;

	//Коэффициенты корреляции:
	double mu_z_ = (mu_z / xi_z_2) / ( 1. + (1./3.) * pow(temp, 2) );
	double mu_y_ = mu_y / xi_y_2;
	std::cout << "mu_z_" << std::setw(8) << "= " << mu_z_ << std::endl;
	std::cout << "mu_y_" << std::setw(8) << "= " << mu_y_ << std::endl;

	//Обобщенный коэффициент корреляции:
	double mu = sqrt(1 - sqrt((1 - mu_z_ * mu_z_) * (1 - mu_y_ * mu_y_)));
	std::cout << "mu" << std::setw(11) << "= " << mu << std::endl;

	int c = getch();
}